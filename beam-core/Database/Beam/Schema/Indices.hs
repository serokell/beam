{-# LANGUAGE CPP                  #-}
{-# LANGUAGE UndecidableInstances #-}

module Database.Beam.Schema.Indices
    ( TableIndex (..)
    , Index (..)

    , FieldIndexBuilder (..)
    , IndexBuilder (..)
    , EntityIndices (..)
    , DatabaseIndices

    , mkIndexName
    , buildDbIndices
    , tableIndex
    , dbIndices
    , mergeDbIndices
    , defaultDbIndices
    , addDefaultDbIndices
    ) where

import Control.Monad.Writer.Strict (runWriter, tell)

import Data.DList (DList)
import qualified Data.DList as DL
import Data.Functor.Identity
import Data.List.NonEmpty (NonEmpty (..), sort)
import Data.Monoid (Endo (..))
import Data.Proxy
import Data.Text (Text)
import qualified Data.Text as T

import GHC.Exts (Constraint, fromList)
import GHC.Generics hiding (C, R)
import GHC.TypeLits

import Database.Beam.Schema.Lookup
import Database.Beam.Schema.Tables

-- TODO: format imports as they were everywhere!

-- | Single index settings for the given table.
newtype TableIndex = TableIndex (NonEmpty Text)
    deriving (Show, Semigroup)

instance Eq TableIndex where
    TableIndex f1 == TableIndex f2 = sort f1 == sort f2
instance Ord TableIndex where
    TableIndex f1 `compare` TableIndex f2 = sort f1 `compare` sort f2

-- | Single index settings.
data Index = Index !Text !TableIndex
    deriving (Show, Eq, Ord)

-- | Make a name for autogenerated index.
mkIndexName :: Text -> [Text] -> Text
mkIndexName tblNm fields =
    "idx_" <> tblNm <> "_" <> T.intercalate "_" fields

-- | Indices for a 'table'.
--
--   Essentially a wrapper over a set of indices.
--
--   TODO:
--   Usually you use the 'defaultDbSettings' function to generate an appropriate
--   naming convention for you, and then modify it with 'withDbModification' if
--   necessary. Under this scheme, the field can be renamed using the 'IsString'
--   instance for 'TableField', or the 'fieldNamed' function.
newtype EntityIndices be db entity = EntityIndices
    { _entityIndices :: DList (DatabaseEntity be db entity -> Index)
      -- ^ Multiple indices info assuming the database settings is given.
      --   We have to accept database settings here rather than take them at index building
      --   stage because migrations require that.
    } deriving (Semigroup, Monoid)

-- | When parameterized by this entity tag, a database type will hold
--   a schema of indices, i.e. a way to build material indices when corresponding database
--   settings are provided. Under the hood, each entity type is transformed into its
--   'EntityIndices' type. For tables this includes, accordingly, indices for this table.
type DatabaseIndices be db = db (EntityIndices be db)

-- | Construct material indices from given database schema and indices schema.
buildDbIndices
    :: forall be db.
       Database be db
    => DatabaseSettings be db -> DatabaseIndices be db -> [Index]
buildDbIndices dbSettings dbIdxs =
    let (_ :: DatabaseSettings be db, indices) =
            runWriter $ zipTables (Proxy @be)
                (\dbEntity (EntityIndices mkIndices) -> do
                    tell [ mkIndex dbEntity | mkIndex <- DL.toList mkIndices ]
                    return dbEntity)
                dbSettings dbIdxs
    in indices

-- | Return empty 'DatabaseIndices' (not counting indices created automatically like
--   primary key index). You can use it like
--
-- > dbIndices { tbl1 = tableIndex field1 <> tableIndex (field2, field3) }
dbIndices :: forall be db. Database be db => DatabaseIndices be db
dbIndices = runIdentity $ zipTables (Proxy @be) (\_ _ -> pure mempty) undefined undefined

-- | Combine two indices settings.
mergeDbIndices
    :: forall be db.
       Database be db
    => DatabaseIndices be db -> DatabaseIndices be db -> DatabaseIndices be db
mergeDbIndices i1 i2 =
    runIdentity $ zipTables (Proxy @be) (\ei1 ei2 -> pure (ei1 <> ei2)) i1 i2


-- * Manual indices definition

-- | Helper for 'IsNotEmptyData'.
type family GIsNotEmptyData (item :: Symbol) (rep :: * -> *) :: Constraint where
    GIsNotEmptyData item (D1 _d (C1 _c U1)) =
        TypeError ('Text item ':<>: 'Text " without fields is not allowed here")
    GIsNotEmptyData _ _ = ()

-- | Ensures a datatype has at least one field.
type IsNotEmptyData item x = (Generic x, GIsNotEmptyData item (Rep x))

-- | Gathers index fields from the given field of a table.
class FieldIndexBuilder field where
    buildFieldIndex :: field -> TableIndex

instance FieldIndexBuilder (TableField table a) where
    buildFieldIndex field = TableIndex . (:| []) $ _fieldName field

instance (Beamable (PrimaryKey table),
          IsNotEmptyData "Primary key" (PrimaryKey table Identity)) =>
         FieldIndexBuilder (PrimaryKey table (TableField table')) where
    buildFieldIndex =
        TableIndex . fromList .
        allBeamValues (\(Columnar' (TableField fieldNm)) -> fieldNm)

instance (Beamable (PrimaryKey table),
          IsNotEmptyData "Primary key" (PrimaryKey table Identity)) =>
         FieldIndexBuilder (PrimaryKey table (Nullable (TableField table'))) where
    buildFieldIndex =
        TableIndex . fromList .
        allBeamValues (\(Columnar' (TableField fieldNm)) -> fieldNm)

-- | Gathers index fields from a user-supplied pack of table fields.
class IndexBuilder table a where
    buildIndex :: TableSettings table -> a -> TableIndex

-- | Field accessors are building blocks for indices.
instance (f ~ TableField table, table ~ table', FieldIndexBuilder field) =>
         IndexBuilder table' (table f -> field) where
    buildIndex settings getter =
        buildFieldIndex $ getter settings

instance (IndexBuilder table a, IndexBuilder table b) =>
         IndexBuilder table (a, b) where
    buildIndex settings (a, b) = buildIndex settings a <> buildIndex settings b

instance (IndexBuilder table a, IndexBuilder table b, IndexBuilder table c) =>
         IndexBuilder table (a, b, c) where
    buildIndex settings (a, b, c) =
        buildIndex settings a <> buildIndex settings b <> buildIndex settings c

-- | Make a table index builder covering the specified fields.
--   Basic usage is to pass a table field accesor or a tuple of them to this function.
--   Currently no more than 3 elements in tuple are supported, but feel free to nest
--   tuples.
--   Order of fields is preserved: tuples expand straightforwardly, while primary keys
--   expand to a list of fields in the same order as they are mentioned in the
--   corresponding constructor.
tableIndex
    :: IndexBuilder table a
    => a
    -> EntityIndices be db (TableEntity table)
tableIndex builder =
    EntityIndices . DL.singleton $
        \(DatabaseEntity (DatabaseTable tblName tblSettings)) ->
            Index tblName $ buildIndex tblSettings builder


-- * Automatic indices definition

-- | Generic helper for 'AutoTableIndices'.
--   Since 'DatabaseIndices' accepts exact names in deferred way, knowing just a structure
--   of the database is enough. The same applies to all the next typeclasses.
class GAutoTableIndices be db (x :: * -> *) where
    autoTableIndices' :: Proxy x -> Endo (DatabaseIndices be db)

instance GAutoTableIndices be db x => GAutoTableIndices be db (M1 i f x) where
    autoTableIndices' _ = autoTableIndices' (Proxy @x)

instance (GAutoTableIndices be db x, GAutoTableIndices be db y, Database be db) =>
          GAutoTableIndices be db (x :*: y) where
    autoTableIndices' _ = autoTableIndices' (Proxy @x) <> autoTableIndices' (Proxy @y)

instance Database be db => GAutoTableIndices be db (Rec0 x) where
    autoTableIndices' _ = mempty

instance {-# OVERLAPPING #-}
         (Database be db, Table tbl, Beamable (PrimaryKey tbl),
          GetDbEntity TableEntity EntityIndices tbl be db) =>
         GAutoTableIndices be db (Rec0 (PrimaryKey tbl f)) where
    autoTableIndices' _ =
        if tableValuesNeeded (Proxy @(PrimaryKey tbl)) == 0
        then mempty
        else Endo $ \prevRes -> overDbEntity (Proxy @TableEntity) (Proxy @tbl) prevRes $
                EntityIndices . DL.singleton $
                    \(DatabaseEntity (DatabaseTable tblName tblSettings)) ->
                        let pkFields = allBeamValues
                                          (\(Columnar' (TableField fieldNm)) -> fieldNm)
                                          (primaryKey tblSettings)
                            -- unsafe call, but at this point we know the list is not empty
                            tblIndex = TableIndex $ fromList pkFields
                        in Index tblName tblIndex

-- | Traverses fields of the given table and builds indices for all encountered 'PrimaryKey's.
class AutoEntityIndex be db tbl where
    autoEntityIndex :: Proxy tbl -> Endo (DatabaseIndices be db)

-- Other types of entities are approaching, and we probably don't want to define
-- instances for all of them.
-- | Traverses the given part of table and for every field which is some 'PrimaryKey'
-- makes corresponding SQL index in the referred table.
-- If a foreign key cannot be resolved within the given database, compile error arises.
instance {-# OVERLAPPABLE #-}
         AutoEntityIndex be db entity where
    autoEntityIndex _ = mempty

instance (GAutoTableIndices be db (Rep (tbl Exposed))) =>
         AutoEntityIndex be db (TableEntity tbl) where
    autoEntityIndex _ = autoTableIndices' (Proxy @(Rep (tbl Exposed)))

-- | Traverses all tables in database and builds indices for all encountered 'PrimaryKey's.
class GAutoDbIndices be db (x :: * -> *) where
    autoDbIndices' :: Proxy x -> Endo (DatabaseIndices be db)

instance GAutoDbIndices be db x => GAutoDbIndices be db (M1 i f x) where
    autoDbIndices' _ = autoDbIndices' (Proxy @x)

instance (GAutoDbIndices be db x, GAutoDbIndices be db y) =>
         GAutoDbIndices be db (x :*: y) where
    autoDbIndices' _ = autoDbIndices' (Proxy @x) <> autoDbIndices' (Proxy @y)

instance AutoEntityIndex be db tbl =>
         GAutoDbIndices be db (Rec0 (EntityIndices be db tbl)) where
    autoDbIndices' _ = autoEntityIndex @be @db (Proxy @tbl)

-- | Automatically creates indices for every 'PrimaryKey' embedded into a table, for
-- "JOIN"s sake.
-- Resulting indices appear exactly in the order in which 'PrimaryKey's are encountered in
-- the database. Indices may repeat (TODO: note that it is okay, or not? Move "if not exists" to settings?).
defaultDbIndices
    :: forall be db.
       (Database be db,
        Generic (DatabaseIndices be db), GAutoDbIndices be db (Rep (DatabaseIndices be db)))
    => DatabaseIndices be db
defaultDbIndices = appEndo (autoDbIndices' (Proxy @(Rep (DatabaseIndices be db)))) dbIndices

-- | Attaches default indices to the given ones. Usually more convenient than plain
--   'defaultDbIndices':
--
-- > ... `withDbIndices` addDefaultDbIndices dbIndices{ table1 = ..., ... }
addDefaultDbIndices
    :: (Database be db,
        Generic (DatabaseIndices be db), GAutoDbIndices be db (Rep (DatabaseIndices be db)))
    => DatabaseIndices be db -> DatabaseIndices be db
addDefaultDbIndices = mergeDbIndices defaultDbIndices
