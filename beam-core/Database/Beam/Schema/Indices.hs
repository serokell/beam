{-# LANGUAGE CPP                  #-}
{-# LANGUAGE UndecidableInstances #-}

module Database.Beam.Schema.Indices
    ( TableIndex (..)
    , Index (..)

    , FieldIndexBuilder (..)
    , IndexBuilder (..)
    , EntityIndices (..)
    , DatabaseIndices

    , mkIndexName
    , buildDbIndices
    , tableIndex
    , dbIndices
    , mergeDbIndices
    , defaultDbIndices
    , addDefaultDbIndices
    ) where

import Control.Monad.Writer.Strict (runWriter, tell)

import Data.DList (DList)
import qualified Data.DList as DL
import Data.Functor.Identity
import Data.List.NonEmpty (NonEmpty (..), sort)
import Data.Proxy
import Data.Text (Text)
import qualified Data.Text as T

import GHC.Exts (Constraint, fromList)
import GHC.Generics hiding (C, R)
import GHC.TypeLits

import Database.Beam.Schema.Tables

-- TODO: format imports as they were everywhere!

-- | Single index settings for the given table.
newtype TableIndex = TableIndex (NonEmpty Text)
    deriving (Show, Semigroup)

instance Eq TableIndex where
    TableIndex f1 == TableIndex f2 = sort f1 == sort f2
instance Ord TableIndex where
    TableIndex f1 `compare` TableIndex f2 = sort f1 `compare` sort f2

-- | Single index settings.
data Index = Index !Text !TableIndex
    deriving (Show, Eq, Ord)

-- | Make a name for autogenerated index.
mkIndexName :: Text -> [Text] -> Text
mkIndexName tblNm fields =
    "idx_" <> tblNm <> "_" <> T.intercalate "_" fields

-- | Indices for a 'table'.
--
--   Essentially a wrapper over a set of indices.
--
--   TODO:
--   Usually you use the 'defaultDbSettings' function to generate an appropriate
--   naming convention for you, and then modify it with 'withDbModification' if
--   necessary. Under this scheme, the field can be renamed using the 'IsString'
--   instance for 'TableField', or the 'fieldNamed' function.
newtype EntityIndices be db entity = EntityIndices
    { _entityIndices :: DList (DatabaseEntity be db entity -> Index)
      -- ^ Multiple indices info assuming the database settings is given.
      --   We have to accept database settings here rather than take them at index building
      --   stage because migrations require that.
    } deriving (Semigroup, Monoid)

-- | When parameterized by this entity tag, a database type will hold
--   a schema of indices, i.e. a way to build material indices when corresponding database
--   settings are provided. Under the hood, each entity type is transformed into its
--   'EntityIndices' type. For tables this includes, accordingly, indices for this table.
type DatabaseIndices be db = db (EntityIndices be db)

-- | Construct material indices from given database schema and indices schema.
buildDbIndices
    :: forall be db.
       Database be db
    => DatabaseSettings be db -> DatabaseIndices be db -> [Index]
buildDbIndices dbSettings dbIdxs =
    let (_ :: DatabaseSettings be db, indices) =
            runWriter $ zipTables (Proxy @be)
                (\dbEntity (EntityIndices mkIndices) -> do
                    tell [ mkIndex dbEntity | mkIndex <- DL.toList mkIndices ]
                    return dbEntity)
                dbSettings dbIdxs
    in indices

-- | Return empty 'DatabaseIndices' (not counting indices created automatically like
--   primary key index). You can use it like
--
-- > dbIndices { tbl1 = tableIndex field1 <> tableIndex (field2, field3) }
dbIndices :: forall be db. Database be db => DatabaseIndices be db
dbIndices = runIdentity $ zipTables (Proxy @be) (\_ _ -> pure mempty) undefined undefined

-- | Combine two indices settings.
mergeDbIndices
    :: forall be db.
       Database be db
    => DatabaseIndices be db -> DatabaseIndices be db -> DatabaseIndices be db
mergeDbIndices i1 i2 =
    runIdentity $ zipTables (Proxy @be) (\ei1 ei2 -> pure (ei1 <> ei2)) i1 i2


-- * Manual indices definition

-- | Helper for 'IsNotEmptyData'.
type family GIsNotEmptyData (item :: Symbol) (rep :: * -> *) :: Constraint where
    GIsNotEmptyData item (D1 _d (C1 _c U1)) =
        TypeError ('Text item ':<>: 'Text " without fields is not allowed here")
    GIsNotEmptyData _ _ = ()

-- | Ensures a datatype has at least one field.
type IsNotEmptyData item x = (Generic x, GIsNotEmptyData item (Rep x))

-- | Gathers index fields from the given field of a table.
class FieldIndexBuilder field where
    buildFieldIndex :: field -> TableIndex

instance FieldIndexBuilder (TableField table a) where
    buildFieldIndex field = TableIndex . (:| []) $ _fieldName field

instance (Beamable (PrimaryKey table),
          IsNotEmptyData "Primary key" (PrimaryKey table Identity)) =>
         FieldIndexBuilder (PrimaryKey table (TableField table')) where
    buildFieldIndex =
        TableIndex . fromList .
        allBeamValues (\(Columnar' (TableField fieldNm)) -> fieldNm)

instance (Beamable (PrimaryKey table),
          IsNotEmptyData "Primary key" (PrimaryKey table Identity)) =>
         FieldIndexBuilder (PrimaryKey table (Nullable (TableField table'))) where
    buildFieldIndex =
        TableIndex . fromList .
        allBeamValues (\(Columnar' (TableField fieldNm)) -> fieldNm)

-- | Gathers index fields from a user-supplied pack of table fields.
class IndexBuilder table a where
    buildIndex :: TableSettings table -> a -> TableIndex

-- | Field accessors are building blocks for indices.
instance (f ~ TableField table, table ~ table', FieldIndexBuilder field) =>
         IndexBuilder table' (table f -> field) where
    buildIndex settings getter =
        buildFieldIndex $ getter settings

instance (IndexBuilder table a, IndexBuilder table b) =>
         IndexBuilder table (a, b) where
    buildIndex settings (a, b) = buildIndex settings a <> buildIndex settings b

instance (IndexBuilder table a, IndexBuilder table b, IndexBuilder table c) =>
         IndexBuilder table (a, b, c) where
    buildIndex settings (a, b, c) =
        buildIndex settings a <> buildIndex settings b <> buildIndex settings c

-- | Make a table index builder covering the specified fields.
--   Basic usage is to pass a table field accesor or a tuple of them to this function.
--   Currently no more than 3 elements in tuple are supported, but feel free to nest
--   tuples.
--   Order of fields is preserved: tuples expand straightforwardly, while primary keys
--   expand to a list of fields in the same order as they are mentioned in the
--   corresponding constructor.
tableIndex
    :: IndexBuilder table a
    => a
    -> EntityIndices be db (TableEntity table)
tableIndex builder =
    EntityIndices . DL.singleton $
        \(DatabaseEntity (DatabaseTable tblName tblSettings)) ->
            Index tblName $ buildIndex tblSettings builder

-- | For the given part of table @tblp@, indices derived from it.
type TableIndicesBuilder tblp = DList (tblp -> TableIndex)

-- | Helper for GAutoTableIndices
contramapTableIndicesBuilder :: (b -> a) -> TableIndicesBuilder a -> TableIndicesBuilder b
contramapTableIndicesBuilder f = fmap (. f)

-- * Automatic indices definition

-- | Generic helper for 'AutoTableIndices'.
class GAutoTableIndices (x :: * -> *) where
    -- | Returns list of deferred indices.
    --   Exactly this type is required, later in migrations knowing that list size does
    --   not depend on names (only on structure of the database) is important.
    autoTableIndices' :: DList (x p -> TableIndex)

instance GAutoTableIndices x => GAutoTableIndices (M1 i f x) where
    autoTableIndices' = contramapTableIndicesBuilder unM1 $ autoTableIndices' @x

instance (GAutoTableIndices x, GAutoTableIndices y) =>
          GAutoTableIndices (x :*: y) where
    autoTableIndices' =
        contramapTableIndicesBuilder (\(x :*: _) -> x) (autoTableIndices' @x) <>
        contramapTableIndicesBuilder (\(_ :*: y) -> y) (autoTableIndices' @y)

instance GAutoTableIndices (Rec0 x) where
    autoTableIndices' = mempty

instance {-# OVERLAPPING #-}
         Beamable (PrimaryKey tbl') =>
         GAutoTableIndices (Rec0 (PrimaryKey tbl' (TableField tbl))) where
    autoTableIndices' =
        if tableValuesNeeded (Proxy @(PrimaryKey tbl')) == 0
        then DL.empty
        else DL.singleton $ \(K1 referringField) ->
            let pkFields = allBeamValues
                              (\(Columnar' (TableField fieldNm)) -> fieldNm)
                              referringField
                -- unsafe call, but at this point we know the list is not empty
            in TableIndex $ fromList pkFields

instance {-# OVERLAPPING #-}
         Beamable (PrimaryKey tbl') =>
         GAutoTableIndices (Rec0 (PrimaryKey tbl' (Nullable (TableField tbl)))) where
    autoTableIndices' =
        if tableValuesNeeded (Proxy @(PrimaryKey tbl')) == 0
        then DL.empty
        else DL.singleton $ \(K1 referringField) ->
            let pkFields = allBeamValues
                              (\(Columnar' (TableField fieldNm)) -> fieldNm)
                              referringField
                -- unsafe call, but at this point we know the list is not empty
            in TableIndex $ fromList pkFields

-- | Traverses fields of the given table and builds indices for all encountered 'PrimaryKey's.
class AutoEntityIndex be db tbl where
    autoEntityIndex :: Proxy tbl -> EntityIndices be db tbl

-- Other types of entities are approaching, and we probably don't want to define
-- instances for all of them.
-- | Traverses the given table and for every field which is some 'PrimaryKey'
-- makes corresponding SQL index, this allows "JOIN"s on this table perform nicely.
instance {-# OVERLAPPABLE #-}
         AutoEntityIndex be db entity where
    autoEntityIndex _ = mempty

instance (Generic (TableSettings tbl),
          GAutoTableIndices (Rep (TableSettings tbl))) =>
         AutoEntityIndex be db (TableEntity tbl) where
    autoEntityIndex _ =
        EntityIndices $ flip fmap autoTableIndices' $
            \mkIndex (DatabaseEntity (DatabaseTable tblName tblSettings)) ->
                Index tblName (mkIndex (from tblSettings))

-- | Traverses all tables in database and builds indices for all encountered 'PrimaryKey's.
class GAutoDbIndices (x :: * -> *) where
    autoDbIndices' :: x p

instance GAutoDbIndices x => GAutoDbIndices (M1 i f x) where
    autoDbIndices' = M1 autoDbIndices'

instance (GAutoDbIndices x, GAutoDbIndices y) =>
         GAutoDbIndices (x :*: y) where
    autoDbIndices' = autoDbIndices' :*: autoDbIndices'

instance AutoEntityIndex be db tbl =>
         GAutoDbIndices (Rec0 (EntityIndices be db tbl)) where
    autoDbIndices' = K1 $ autoEntityIndex @be @db (Proxy @tbl)

-- | Automatically creates indices for every 'PrimaryKey' embedded into a table, for
-- "JOIN"s sake.
-- Resulting indices appear exactly in the order in which 'PrimaryKey's are encountered in
-- the database. Indices may repeat (TODO: note that it is okay, or not? Move "if not exists" to settings?).
defaultDbIndices
    :: forall be db.
       (Database be db,
        Generic (DatabaseIndices be db), GAutoDbIndices (Rep (DatabaseIndices be db)))
    => DatabaseIndices be db
defaultDbIndices = to autoDbIndices'

-- | Attaches default indices to the given ones. Usually more convenient than plain
--   'defaultDbIndices':
--
-- > ... `withDbIndices` addDefaultDbIndices dbIndices{ table1 = ..., ... }
addDefaultDbIndices
    :: (Database be db,
        Generic (DatabaseIndices be db), GAutoDbIndices (Rep (DatabaseIndices be db)))
    => DatabaseIndices be db -> DatabaseIndices be db
addDefaultDbIndices = mergeDbIndices defaultDbIndices
